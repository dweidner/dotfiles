#!/usr/bin/env bash

#
# Backup Utility
#
# This script backups an OS X system to an external volume, effectively
# cloning it. It is based on [0], [1], [2] and [3] for OS X and [4] and [5] for
# Linux.
#
# Sources:
# [0] https://gist.github.com/necolas/1145450
# [1] https://gist.github.com/tvwerkhoven/4541989
# [2] http://rajeev.name/2008/09/01/automated-osx-backups-with-launchd-and-rsync/
# [3] http://nicolasgallagher.com/mac-osx-bootable-backup-drive-with-rsync/
# [4] https://wiki.archlinux.org/index.php/Full_System_Backup_with_rsync
# [5] http://xpt.sourceforge.net/techdocs/nix/disk/general/disk16-CloneOrBackupDisks/single/
#

SCRIPT_NAME="${0##*/}"

BACKUP_IGNORE="$HOME/.backup_ignore"
BACKUP_SRC="${BACKUP_SRC:-/}"
BACKUP_DST="${BACKUP_DST:-/Volumes/Backup}"

#
# Displays script information.
#
# Usage: header
#
header() {
  cat <<"EOF"

Backup Utility

This script backups an OS X system to an external volume, effectively
cloning it.

Root priviliges are required to ensure all files are copied correctly.
You will be prompted for a password...

EOF
}

#
# Ask for user input.
#
# Usage: seek_confirmation question
#
# $1 = Question to ask.
#
seek_confirmation() {
  read -r -n 1 -p "$* (y/n) "
  echo
}

#
# Test whether the user confirmed a question asked via readline.
#
# Usage: is_confirmed
#
is_confirmed() {
  [[ "$REPLY" =~ ^[YyJj]$ ]]
}

#
# Check if the given directory is listed in the list of mounted volumes.
# Backups should always be copied to an external volume.
#
# Usage: is_external_disk dir
#
# $1 = Directory to test
#
is_external_disk() {
  local dst="$1"
  local name="${1##*/}"
  local id="$(mount | grep "$name" | awk '{ print $1 }')"
  [ "$name" -a "$id" ]
}

#
# Run the rsync backup with the following flags:
#
# --archive
#   --recursive:     traverse all directories
#   --links:         keep symlinks
#   --perms:         preserve perms
#   --times:         preserve mod times
#   --owner:         preserve owner (super-user only)
#   --group:         preserve group
#   --devices:       preserve device files (super-user only)
#   --specials:      preserve special files
# --hard-links:      preserve hard links
# --fileflags:       preserve file-flags
# --acls:            preserve ACLs
# --hfs-compression: preserve HFS compression if supported
# --protect-decmpfs: preserve HFS compression as xattrs
# --crtimes:         preserve create times
# --one-file-system: don't cross FSs
# --delete:          delete extraneous files from destination dirs
#
# Usage: backup src dst
#
# $1 = Source directory
# $2 = Target directory of the backup
#
backup() {
  typeset -a flags

  # Ask the user if we should ignore some files during the backup
  if [ -r "$BACKUP_IGNORE" ]; then
    seek_confirmation "$SCRIPT_NAME: Found a .backup_ignore file in your home directory. Do you want to use that file?"

    if [[ "$REPLY" =~ ^[YyJj]$ ]]; then
      flags+=( --exclude-from="$BACKUP_IGNORE" )
    fi
  fi

  # Create a clone of the source directory using rsync
  sudo time rsync \
    "${flags[*]}" \
    --archive \
    --hard-links \
    --fileflags \
    --acls \
    --hfs-compression \
    --protect-decmpfs \
    --crtimes \
    --one-file-system \
    --update \
    --delete \
    "$src" \
    "$dst"
}

#
# Script entry point
#
# $1 = Source directory
# $2 = Target directory of the backup
#
main() {
  # Allow users to customize source and destination directory
  local src="${1:-$BACKUP_SRC}"
  local dst="${2:-$BACKUP_DST}"

  # Ask for root priviliges
  header
  sudo -v
  echo

  # Ensure the source directory is available
  if [ ! -r "$src" ]; then
    echo "$SCRIPT_NAME: Can not read from source '$src'"
    return 1
  fi

  # Ensure destination directory is available
  if [ ! -d "$dst" ]; then
    echo "$SCRIPT_NAME: Can not write to destination '$dst'"
    return 1
  fi

  # Ensure the destination directory is an external volume
  if ! is_external_disk "$dst"; then
    echo "$SCRIPT_NAME: Destination '$dst' not found in the list of mounted volumes - are you sure this is an external disk?"
    return 1
  fi

  # Temporarily disable time machine on OSX
  if type tmutil >/dev/null 2>&1; then
    echo "$SCRIPT_NAME: Temporarily disabling Time Machine..."
    sudo tmutil disable
  fi

  # Start the backup process
  echo "$SCRIPT_NAME: Running backup from '$src' to '$dst'. This may take some time..."
  backup "$src" "$dst"

  # Finish the backup process
  echo "$SCRIPT_NAME: Backup complete."

  # Make the backup bootable
  if type bless >/dev/null 2>&1; then
   if [ -d "$dst/System/Library/CoreServices" ]; then
      bless -folder "$dst/System/Library/CoreServices"
    fi
  fi

  # Re-enable time machine
  if type tmutil >/dev/null 2>&1; then
    echo "$SCRIPT_NAME: Enabling Time Machine..."
    sudo tmutil enable
  fi
}

main "$@"
