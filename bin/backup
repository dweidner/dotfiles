#!/usr/bin/env bash

BACKUP_LOGFILE="$HOME/Library/Logs/backup.log"
BACKUP_IGNORE="$HOME/.backup_ignore"

#
# Telss users how to use the script
#
# Usage: usage
#
usage() {
  echoc "usage: backup [source] [target]"
}

#
# Displays script information.
#
# Usage: header
#
header() {
  echoc ""
  echoc "Backup Utility" "bold"
  echoc "
  This script copies the given source directory and all its
  contents to a backup directory.

  Root priviliges are required to ensure all files are copied correctly.
  You will be prompted for a password...
  "
}

#
# Test if rsync is available in the users $PATH.
#
# Usage: is_rsync_executable
#
is_rsync_executable() {
  type "rsync" >/dev/null 2>&1
}

#
# Test if the given directory is readable.
#
# Usage: is_dir_readable directory
#
# $1 = Path to the direcotry
#
is_dir_readable() {
  [ -d "$1" ]
}

#
# Test if the given file is readable.
#
# Usage: is_file_readable file
#
# $1 = Path to the file
#
is_file_readable() {
  [ -f "$1" ]
}

#
# Print a message in a given color.
#
# Usage: echoc message [color] [format]
#
# $1 = Message to print
# $2 = Color to use [red|green|yellow]
#
echoc() {
  local msg="$1"
  local color="$2"

  local prefix
  local suffix

  if [ -n "$color" ]; then
    case "$color" in
      red)     prefix=$(tput setaf 1)  ;;
      green)   prefix=$(tput setaf 2)  ;;
      yellow)  prefix=$(tput setaf 3)  ;;
      bold)    prefix=$(tput bold)     ;;
    esac
    suffix=$(tput sgr0)
  fi

  printf "%b%s%b\n" "$prefix" "$msg" "$suffix"
}

#
# Ask for user input.
#
# Usage: seek_confirmation question
#
# $1 = Question to ask.
#
seek_confirmation() {
  read -r -n 1 -p "$(tput setaf 2)$* (y/n) $(tput sgr0)"
  printf "\n"
}

#
# Display backup statistics.
#
# Usage: show_statistics starttime endtime [logfile]
#
#  $1  = Time the backup was started
#  $2  = Time the backup was finished
#
show_statistics() {
  local duration=$((2 - 1))

  if [ "$duration" -lt 60 ]; then
    duration="$duration seconds"
  elif [ "$duration" -lt 3600 ]; then
    duration="$((duration / 60)) minutes and $((duration % 60)) seconds"
  else
    duration="$((duration / 3600)) hours and $(((duration % 3600) / 60)) minutes"
  fi

  local num_files
  num_files=$(awk '/Number of files: /{print $7}' "$BACKUP_LOGFILE")

  local num_files_transferred
  num_files_transferred=$(awk '/Number of regular files transferred: /{print $NF}' "$BACKUP_LOGFILE")

  printf '=%.0s' {1..50}; printf '\n'
  echoc "Summary:" "bold"
  echoc "- Number of files: $num_files"
  echoc "- Number of regular files transferred: $num_files_transferred"
  echoc "- Total Duration: $duration"
  printf '=%.0s' {1..50}; printf '\n\n'
}

#
# Report errors and warnings that occured during
# the backup process.
#
# Usage: show_errors
#
show_errors() {
  local warnings
  local num_warnings

  warnings=$(grep "rsync:" "$BACKUP_LOGFILE" | awk -F"rsync: " '{print "- "$2}')
  num_warnings=$(echo "$warnings" | wc -l | tr -d ' ')

  if [ -z "$warnings" ]; then
    warnings="– None –"
  fi

  echoc "Warnings ($((num_warnings - 1))):" "yellow"
  echoc "$warnings"; echo

  local errors
  local num_errors

  errors=$(grep "rsync error:" "$BACKUP_LOGFILE" | awk -F"rsync error: " '{print "- "$2}')
  num_errors=$(echo "$errors" | wc -l | tr -d ' ')

  if [ -z "$errors" ]; then
    errors="– None –"
  fi

  echoc "Errors ($((num_errors - 1))):" "red"
  echoc "$errors"; echo

  return "$((num_errors - 1))"
}

#
# Run incremental backup using rsync and bless.
#
# Usage: backup source target
#
#  $1  = Source directory
#  $2  = Target direcotry
#
backup() {
  local source="$1"
  local target="$2"

  # Remove old logfiles
  if [ -f "$BACKUP_LOGFILE" ]; then
    rm -f "$BACKUP_LOGFILE"
  fi

  sudo rsync --archive \
         --hard-links \
         --executability \
         --xattrs \
         --acls \
         --one-file-system \
         --verbose \
         --delete \
         --progress \
         --stats \
         --timeout=999 \
         --log-file="$BACKUP_LOGFILE" \
         --exclude-from="$BACKUP_IGNORE" \
         "$source" \
         "$target"

  # Check for errors
  if [ $? -ne 0 ]; then
    echoc "» An error occured during the backup. See the log for more details." "red"
  else
    echoc "» Backup finished successfully." "green"
  fi

  # Make the backup bootable
  seek_confirmation "» Make the backup bootable?"

  if [[ "$REPLY" =~ ^[YyJj]$ ]]; then
    sudo bless -folder "$target/System/Library/CoreServices"

    # Check for errors
    if [ $? -ne 0 ]; then
      echoc "» Could not make the backup bootable." "red"
      return 1
    else
      echoc "» Your backup is now bootable." "green"
    fi
  fi

  return 0
}

#
# Script entry point
#
# $1 = Source directory
# $2 = Target directory of the backup
#
main() {
  local source="$1"
  local target="$2"

  # Ensure any arguments are given
  if [[ -z "$source" || -z "$target" ]]; then
    usage
    return 1
  fi

  # Ask for root priviliges
  header
  sudo -v
  echo

  # Ensure rsync is available
  if ! is_rsync_executable; then
    echoc "backup: rsync not found: Ensure it is in your PATH." "red"
    return 1
  fi

  # Ensure the source directory is available
  if ! is_dir_readable "$source"; then
    echoc "backup: Source directory not found: $source" "red"
    return 1
  fi

  # Ensure target directory is available
  if ! is_dir_readable "$target"; then
    echoc "backup: Target directory not found: $target" "red"
    return 1
  fi

  # Ask the user if we should ignore some files during the backup
  if is_file_readable "$BACKUP_IGNORE"; then
    seek_confirmation "» Found a .backup_ignore file in your home directory. Do you want to use that file?"

    if [[ "$REPLY" =~ ^[Nn]$ ]]; then
      BACKUP_IGNORE=""
    fi
  fi

  # Start the backup process
  echoc "» Running backup. This may take some time..." "green"; echo

  local starttime
  starttime="$(date +%s)"

  backup "$source" "$target"

  local endtime
  endtime="$(date +%s)"

  # Summarize results
  show_statistics "$starttime" "$endtime"
  show_errors
  echoc "» Backup done. Relax :)." "green"

  return 0
}

main "$@"
