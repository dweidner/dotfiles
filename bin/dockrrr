#!/usr/bin/env bash
#
# @file Custom wrapper for frequently used docker compose services

# (1) Global Variables -------------------------------------------------- {{{1

export WWWUSER="${WWWUSER:-$UID}"
export WWWGROUP="${WWWGROUP:-$(id -g)}"

if [[ -f "./.env" ]]; then
  source "./.env"
fi



# (2) Utility Functions ------------------------------------------------- {{{1

#
# Determine whether docker is running
#
# usage: is_docker_running
#
is_docker_running() {
  docker info >/dev/null 2>&1
}

#
# Determine if any services are running
#
# usage: is_any_service_running
#
is_any_service_running() {
  docker compose ps 2>&1 | grep --quiet "running"
}

#
# Determine whether a docker compose service is running.
#
# usage: is_service_running <service>
#
is_service_running() {
  docker compose ps "${1}" 2>&1 | grep --quiet "running"
}

#
# Determine whether a command with the given name exists in the current
# environment.
#
# usage: command_exists <name>
#
command_exists() {
  command -v "${1}" >/dev/null 2>&1
}

#
# Print a status message.
#
# usage: print_message <message>
#
print_message() {
  echo -e "\\033[0;34m==> $*\\033[0;m"
}

#
# Print an error message.
#
# usage: print_error <message>
#
print_error() {
  echo -e "\\033[0;31m==> $*\\033[0;m" >&2
}

#
# Print a warning message.
#
# usage: print_warning <message>
#
print_warning() {
  echo -e "\\033[0;33m==> $*\\033[0;m" >&2
}

#
# Confirm a question with the user.
#
# usage: confirm <question>
#
confirm() {
  read -r -p $'\e[0;32m'"==> $* (y/n [n]) "$'\e[0;m' answer

  case "$answer" in
    y|Y) return 0 ;;
    *) return 1 ;;
  esac
}

#
# Get the name of the current docker compose project.
#
# usage: project_name
#
project_name() {
  if [[ -n "${COMPOSE_PROJECT_NAME}" ]]; then
    printf '%s\n' "${COMPOSE_PROJECT_NAME}"
  else
    printf '%s\n' "${PWD##*/}"
  fi
}

#
# Get the container name of a service.
#
# usage: container_name <service>
#
container_name() {
  local service_name="${1}"

  local container_id
  container_id="$(docker compose ps --quiet "${service_name}")"

  docker inspect --format '{{.Name}}' "${container_id}" | cut -c2-
}

#
# Find the first service of multiple candidates that is currently running.
#
# usage: find_service <service> [service] [service] â€¦
#
find_service() {
  for service in "${@}"; do
    if is_service_running "${service}"; then
      echo "${service}"
      return 0
    fi
  done

  return 1
}



# (3) Commands ---------------------------------------------------------- {{{1

# (a) Usage Command ----------------------------------------------------- {{{2

#
# Display usage information.
#
usage() {
  cat <<- CommandUsage
		Dockrrr v1.0.0

		Usage:
		dockrrr <command> [options] [arguments]

		Commands:
		  list      List all available docker compose projects.
		  up        Start all containers of the current project.
		  down      Stop all containers of the current project.
		  restart   Restart all containers of the current project.
		  node      Run a Node command.
		  npm       Run a npm command.
		  npx       Run a npx command.
		  php       Run a snippet of PHP code.
		  composer  Run a Composer command.
		  artisan   Run an Artisan command.
		  drupal    Run a Drupal Console command.
		  drush     Run a Drush command.
		  phpunit   Run a PHPUnit test.
		  mysql     Start a MYSQL CLI session.
		  adminer   Use a browser based database management tool.
	CommandUsage
}

# (b) Start Command ----------------------------------------------------- {{{2

#
# Start all containers of the current docker compose project.
#
# usage: start_services
#
start_services() {
  if is_any_service_running; then
    print_warning "Some Docker containers are already running"

    if confirm "Do you want to shut them down first?"; then
      stop_services
    fi
  fi

  docker compose up --detach --wait
}

# (c) Stop Command ------------------------------------------------------ {{{2

#
# Stop all containers of the current docker compose project.
#
# usage: stop_services
#
stop_services() {
  docker compose down --remove-orphans
}

# (d) List Command ------------------------------------------------------ {{{2

#
# List all docker compose projects.
#
# usage: list_projects
#
list_projects() {
  local directories="${PROJECT_PATH:-"${HOME}/Sites"}"

  while read -rd: directory; do
    find "${directory}" -maxdepth 3 -type f -name "docker-compose.yml" -exec dirname -- {} \;
  done <<< "${directories}:"
}



# (4) Entry Point ------------------------------------------------------- {{{1

#
# Main entry point of the script.
#
# usage: dockrrr [<cmd>] [options] [arguments]
#
main() {
  if ! command_exists "docker"; then
    print_error "Command [docker] is not defined"
    return 1
  fi

  if ! is_docker_running; then
    print_warning "Docker is not running"
    return 1
  fi

  local command="${1:-help}"
  shift 1

  local options=()

  if [[ ! -t 0 ]]; then
    options+=(--no-TTY)
  fi

  local project
  project="$(project_name)"

  local node_service
  node_service="$(find_service "node" "laravel" "laravel.test")"

  local php_service
  php_service="$(find_service "php" "drupal" "wordpress" "laravel" "laravel.test")"

  local mysql_service
  mysql_service="$(find_service "db" "mysql" "mariadb")"

  case "${command}" in
    ls|list)
      list_projects
      ;;
    help)
      usage
      ;;
    up)
      start_services
      ;;
    down)
      stop_services
      ;;
    restart)
      stop_services
      start_services
      ;;
    node)
      docker compose exec "${options[@]}" "${node_service:-node}" \
        node "${@}"
      ;;
    npm)
      docker compose exec "${options[@]}" "${node_service:-node}" \
        npm "${@}"
      ;;
    npx)
      docker compose exec "${options[@]}" "${node_service:-node}" \
        npx "${@}"
      ;;
    php)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        php "${@}"
      ;;
    composer)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        composer "${@}"
      ;;
    artisan)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        php artisan "${@}"
      ;;
    drupal)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        ./vendor/bin/drupal "${@}"
      ;;
    drush)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        ./vendor/bin/drush "${@}"
      ;;
    phpunit)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        ./vendor/bin/phpunit "${@}"
      ;;
    sql)
      docker compose exec "${options[@]}" "${mysql_service:-mysql}" \
        bash -c "MYSQL_PWD=\${MYSQL_PASSWORD} mysql -u \${MYSQL_USER} \${MYSQL_DATABASE}"
      ;;
    sql:dump)
      local today
      today="$(date +%Y-%m-%d)"

      local file
      file="/docker-entrypoint-initdb.d/${1:-${today}-${project}.sql}"

      docker compose exec "${options[@]}" "${mysql_service:-mysql}" \
         bash -c "MYSQL_PWD=\${MYSQL_PASSWORD} mysqldump -u \${MYSQL_USER} \${MYSQL_DATABASE} -r \"${file}\""
      ;;
    sql:restore)
      local input

      if (( $# > 0 )); then
        input="/docker-entrypoint-initdb.d/$*"
      else
        input="/dev/stdin"
      fi

      docker compose exec "${options[@]}" "${mysql_service:-mysql}" \
        bash -c "MYSQL_PWD=\${MYSQL_PASSWORD} mysql -u \${MYSQL_USER} \${MYSQL_DATABASE} < \"${input}\""
      ;;
    adminer)
      docker run --init --rm --interactive --tty \
        --publish "${1:-8080}:8080" \
        --env ADMINER_DEFAULT_SERVER="${mysql_service:-db}" \
        adminer
      ;;
    *)
      print_error "Unknown command [${command}]"
      usage
      ;;
  esac
}

main "$@"



# vim:foldmethod=marker:foldlevel=2
