#!/usr/bin/env bash

# -----------------------------------------------------------------------
# Table of Contents
# -----------------------------------------------------------------------
# 1. Global Variables
# 2. Utility Functions
# 3. Commands
# |- a) Usage Command
# |- b) Help Command
# |- c) Setup Command
# |- d) Update Command
# |- e) Cleanup Command
# 4. Entry Point
# -----------------------------------------------------------------------



# (1) Global Variables -------------------------------------------------- {{{1

set -e

readonly XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"

readonly SCRIPT_DIR="$(dirname "$0")"
readonly DOTFILES="${DOTFILES:-$(dirname "$SCRIPT_DIR")}"



# (2) Utility Functions ------------------------------------------------- {{{1

#
# Determine wheter a given value exists in an array
#
# usage: in_array <needle> <array>
#
in_array() {
  local needle="$1"
  local item

  shift

  for item; do
    if [[ "$needle" == "$item" ]]; then
      return 0
    fi
  done

  return 1
}

#
# Determine whether a command with the given name exists in the current
# environment.
#
# usage: command_exists <name>
#
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

#
# Determine whether a function with the given name exists.
#
# Tries to declare the function which will return with an exit code > 0 if
# a function with the given name already exists (supposed to be faster than
# executing type -f).
#
# usage: function_exists <name>
#
function_exists() {
  declare -fF "$1" >/dev/null
  return $?
}

#
# Confirm a question with the user.
#
# usage: confirm <question>
#
confirm() {
  read -r -p $'\e[0;32m'"$* (y/n [n]) "$'\e[0;m' answer

  case "$answer" in
    y|Y) return 0 ;;
    *) return 1 ;;
  esac
}

#
# Print a status message.
#
# usage: print_message <message>
#
print_message() {
  echo -e "\\033[0;34m$*\\033[0;m"
}

#
# Print a message after a successfull operation.
#
# usage: print_success <message>
#
print_success() {
  echo -e "\\033[0;32m$*\\033[0;m"
}

#
# Print a warning message.
#
# usage: print_warning <message>
#
print_warning() {
  echo -e "\\033[0;33m$*\\033[0;m" >&2
}

#
# Print an error message.
#
# usage: print_error <message>
#
print_error() {
  echo -e "\\033[0;31m$*\\033[0;m" >&2
}

#
# Notify the user that a given command is not defined.
#
# usage: command_not_found <command>
#
command_not_found() {
  print_error "Command [${1}] is not defined\\n"
  usage
  exit 1
}

#
# Notify the user about an invalid option.
#
# usage: unknown_option <name>
#
unknown_option() {
  print_error "Unknown option given [${1}]"
}

#
# Notify the user about an unknown system component.
#
# usage: unknown_component <name>
#
unknown_component() {
  print_error "Unknown system component [${1}]"
}

#
# Create the directory structure for a given file path.
#
# usage: prepare_path <path>
#
prepare_path() {
  local path="${1}"
  local dir
  dir="$(dirname "$path")"

  if [[ -d "${dir}" ]]; then
    return 0
  fi

  mkdir -p "${dir}"
}

#
# Copy a file from the dotfiles repository to the home directory of the
# current user.
#
# usage: copy <source> <target>
#
copy() {
  local source="${DOTFILES}/$1"
  local target="$2"

  if [[ -e "${target}" ]]; then
    if ! confirm "overwrite ${target}?"; then
      print_warning "skipping ${target} …"
      return 1
    fi
  fi

  if ! prepare_path "${target}"; then
    print_error "could not create parent directory"
    return 1
  fi

  cp -f "${source}" "${target}" \
    && print_success "copied file to ${target}"
}

#
# Create a symlink from a file in the dotfiles repository to a file in the
# home directory.
#
# usage: symlink <source> <target>
#
symlink() {
  local source="${DOTFILES}/$1"
  local target="$2"

  if [[ -e "${target}" ]]; then
    if ! confirm "overwrite ${target}?"; then
      print_warning "skipping ${target} …"
      return 1
    fi
  fi

  if ! prepare_path "${target}"; then
    print_error "could not create parent directory"
    return 1
  fi

  ln -fns "${source}" "${target}" \
    && print_success "created symlink at ${target}"
}



# (3) Commands ---------------------------------------------------------- {{{1

# (a) Usage Command ----------------------------------------------------- {{{2

#
# Display a list of available commands.
#
# usage: usage
#
usage() {
  cat <<- EOF
		Dotfiles Utility

		Usage:
		  dotfiles <command> [options] [arguments]

		Commands:
		  cleanup		Cleanup caches of various system components
		  help			Display help for a command
		  setup			Run the initial setup for various system components
		  update		Fetch the latest version of various system components
	EOF
}

# (b) Help Command ------------------------------------------------------ {{{2

#
# Display help for a command.
#
# usage: help <command>
#
help() {
  local commands=("cleanup" "help" "setup" "update")
  local command="${1:-help}"

  if ! in_array "${command}" "${commands[@]}"; then
    command_not_found "$command"
  fi

  "help_${command}_command"
}

#
# Display usage information for the cleanup command.
#
help_cleanup_command() {
  cat <<-EOF
		Usage:
		  cleanup [<component>]
		
		Arguments:
		  component  	Name of the system component to cleanup
		
		Help:
		  The cleanup command purges various caches on the current system and removes
		  older versions of installed commands.
		
		    e.g. dotfiles cleanup homebrew
		
		  In order to cleanup all system components in one go leave out the component
		  name.
		
		    e.g. dotfiles cleanup
		
	EOF
}

#
# Display usage information for the help command.
#
help_help_command() {
  cat <<-EOF
		Usage:
		  help [<command>]
		
		Arguments:
		  command  	Name of the command to display usage information for
		
		Help:
		  The help command displays help for a given command:
		
		    e.g dotfiles help update
		
		  To display a list of available commands, please use the list command.
		
	EOF
}

#
# Display usage information for the setup command.
#
help_setup_command() {
  cat <<-EOF
		Usage:
			setup [<component>]
		
		Arguments:
		  component  	Name of the system component to run the initial setup for.
		
		Help:
		  The setup command can be used to run the initial setup for a specific
		  system component.
		
		    e.g. dotfiles setup php
		
	EOF
}

#
# Display usage information for the update command.
#
help_update_command() {
  cat <<-EOF
		Usage:
			update <component>
		
		Arguments:
		  component  	Name of the system component to update
		
		Help:
		  The update command can be used to fetch the latest version of various
		  system components.
		
		    e.g. dotfiles update homebrew
		
	EOF
}

# (c) Setup Command ----------------------------------------------------- {{{2

#
# Setup development dependencies.
#
# usage: setup [<component>]
#
setup() {
  local -a components=("symlinks" "brew" "tpm" "nvm" "node" "php" "python" "rvm" "ruby")
  local -a queue=( "$@" )

  if (( $# == 0 )); then
    queue=( "${components[@]}" )
  fi

  for component in "${queue[@]}"; do
    if function_exists "setup_${component}"; then
      "setup_${component}"
    else
      unknown_component "${component}"
    fi
  done
}

#
# Create symlinks to included configuration files (uses XDG base
# directories if supported by the application).
#
# @link https://wiki.archlinux.org/index.php/XDG_Base_Directory_support|XDG Base Directory support
#
setup_symlinks() {
  local -a directories=(
    "${XDG_CONFIG_HOME}"
    "${XDG_CACHE_HOME}"
    "${XDG_CACHE_HOME}/bundle"
    "${XDG_CACHE_HOME}/composer"
    "${XDG_CACHE_HOME}/gem"
    "${XDG_CACHE_HOME}/npm"
    "${XDG_CACHE_HOME}/nvim"
    "${XDG_CACHE_HOME}/vim"
    "${XDG_DATA_HOME}"
    "${XDG_DATA_HOME}/bash"
    "${XDG_DATA_HOME}/bundle"
    "${XDG_DATA_HOME}/bundle/plugin"
    "${XDG_DATA_HOME}/dotfiles"
    "${XDG_DATA_HOME}/gem"
    "${XDG_DATA_HOME}/less"
    "${XDG_DATA_HOME}/nvim"
    "${XDG_DATA_HOME}/tmux"
    "${XDG_DATA_HOME}/vim"
    "${XDG_DATA_HOME}/vim/backup"
    "${XDG_DATA_HOME}/vim/swap"
    "${XDG_DATA_HOME}/vim/undo"
  )

  print_message "Creating directories …"

  for directory in "${directories[@]}"; do
    mkdir -p "${directory}" && print_success "created ${directory}"
  done

  print_message "Creating symlinks …"

  symlink "bash/bash_profile"          "${HOME}/.bash_profile"
  symlink "bash/bashrc"                "${HOME}/.bashrc" 
  symlink "bash/completions"           "${XDG_DATA_HOME}/bash-completion/completions"
  symlink "readline/inputrc"           "${XDG_CONFIG_HOME}/readline/inputrc"
  symlink "git/ignore"                 "${XDG_CONFIG_HOME}/git/ignore"
  symlink "git/commitmsg"              "${XDG_CONFIG_HOME}/git/commitmsg"
  symlink "vim/"                       "${HOME}/.vim"
  symlink "vim/nvimrc"                 "${XDG_CONFIG_HOME}/nvim/init.vim"
  symlink "vim/after"                  "${XDG_CONFIG_HOME}/nvim/after"
  symlink "vim/plugin"                 "${XDG_CONFIG_HOME}/nvim/plugin"
  symlink "vim/autoload"               "${XDG_CONFIG_HOME}/nvim/autoload"
  symlink "tmux/tmux.conf"             "${XDG_CONFIG_HOME}/tmux/tmux.conf"
  symlink "misc/default-node-packages" "${XDG_CONFIG_HOME}/nvm/default-packages"
  symlink "misc/gemrc"                 "${XDG_CONFIG_HOME}/gem/gemrc"
  symlink "misc/ctags"                 "${HOME}/.ctags"
  symlink "misc/Brewfile"              "${HOME}/.Brewfile"
  symlink "misc/ignore"                "${HOME}/.ignore"
  symlink "misc/editorconfig"          "${HOME}/.editorconfig"
  symlink "misc/tern-config"           "${HOME}/.tern-config"
  copy    "git/config"                 "${XDG_DATA_HOME}/git/config"
}

#
# Install essential homebrew formulae.
#
setup_brew() {
  command_exists "brew" || return 1

  print_message "Installing homebrew formulae …"
  brew bundle install --global --verbose
  print_success "Installed formulae listed in ~/.Brewfile"
}

#
# Install tmux plugin manager.
#
setup_tpm() {
  print_message "Installing tmux plugin manager …"

  git clone "https://github.com/tmux-plugins/tpm" "${XDG_DATA_HOME}/tmux/plugins/tpm" || {
    print_error "Cannot checkout tpm repository"
    return 1
  }

  print_message "Installing tmux plugins …"

  "${XDG_DATA_HOME}/tmux/plugins/tpm/bin/install_plugins"
  print_error "Not Implemented"
}

#
# Install node version manager.
#
setup_nvm() {
  print_message "Installing nvm …"

  git clone "https://github.com/creationix/nvm.git" "${XDG_DATA_HOME}/nvm" || {
    print_error "Cannot checkout nvm repository"
    return 1
  }

  local version
  version="$(git -C "${XDG_DATA_HOME}/nvm" describe --abbrev=0 --tags --match "v[0-9]*" origin)"

  git -C "${XDG_DATA_HOME}/nvm" checkout "${version}" || {
    print_error "Cannot switch to NVM version [${version}]"
    return 1
  }

  print_message "Installing latest node version …"

  if ! function_exists "nvm"; then
    source "${XDG_DATA_HOME}/nvm/nvm.sh"
  fi

  nvm install --lts
}

#
# Install latest npm version and default packages.
#
setup_node() {
  command_exists "npm" || return 1

  print_message "Installing latest npm version …"
  npm install --global --production npm@latest

  print_message "Installing global node packages …"
  npm install --global --production yo
  npm install --global --production eslint

  while read -r package; do
    if [[ "${package}" != "yo" ]] && [[ "${package}" != "eslint" ]]; then
      npm install --global --production "${package}"
    fi
  done < "${DOTFILES}/misc/default-node-packages"
}

#
# Install global php packages.
#
setup_php() {
  command_exists "composer" || return 1
  command_exists "cgr" || setup_cgr

  print_message "Installing php packages …"

  while read -r package; do
    cgr "$package"
  done < "${DOTFILES}/misc/default-php-packages"
}

#
# Install cgr, a safer alternative to `composer global require`.
#
setup_cgr() {
  command_exists "composer" || return 1

  print_message "Installing cgr …"
  composer global require consolidation/cgr
}

#
# Install latest pip version and default packages.
#
setup_python() {
  command_exists "pip3" || return 1

  print_message "Updating pip …"
  pip3 install --upgrade pip

  print_message "Installing python packages …"

  while read -r package; do
    pip3 install --upgrade "${package}"
  done < "${DOTFILES}/misc/default-python-packages"
}

#
# Install default node packages.
#
setup_node() {
  print_error "Not Implemented"
}

#
# Install ruby version manager.
#
setup_rvm() {
  print_message "Installing rvm …"

  curl -sSL "https://get.rvm.io" \
    | bash -s -- --path "${XDG_DATA_HOME}/rvm" --ignore-dotfiles --ruby
}

#
# Install global gems.
#
setup_ruby() {
  command_exists "rvm" || return 1

  print_message "Installing global gems …"

  while read -r name; do
    rvm @global do gem install "${name}"
  done < "${DOTFILES}/misc/default-gems"
}

# (d) Update Command ---------------------------------------------------- {{{2

#
# Update system components.
#
# usage: update [<component>]
#
update() {
  local -a components=("system" "homebrew" "nvm" "node" "rvm" "tpm")
  local -a queue=( "$@" )

  if (( $# == 0 )); then
    queue=( "${components[@]}" )
  fi

  for component in "${queue[@]}"; do
    if function_exists "update_${component}"; then
      "update_${component}"
    else
      unknown_component "${component}"
    fi
  done
}

#
# Update the operating system
#
update_system() {
  case "$OSTYPE" in
    darwin*) update_macos ;;
  esac
}

#
# Update macOS from the command line
#
update_macos() {
  print_message "Updating macOS (requires root privileges) …"

  sudo softwareupdate --install --all \
    && print_success "Updated macOS."
}

#
# Update homebrew the missing package manager for macOS
#
update_homebrew() {
  command_exists "brew" || return 1

  print_message "Updating homebrew …"
  brew update --quiet & wait

  print_message "Updating homebrew formulae …"

  local outdated_formulae
  outdated_formulae="$(brew outdated --quiet)"

  wait

  if [[ -z "$outdated_formulae" ]]; then
    print_success "Installed formulae are already up-to-date."
    return 0
  fi

  print_message "Upgrading outdated formulae …"
  brew upgrade & wait
  print_success "Upgraded outdated formulae."
}

#
# Update the node version manager
#
update_nvm() {
  cd -- "$NVM_DIR" 2>/dev/null || return 1

  function_exists "nvm" || source "$NVM_DIR/nvm.sh"
  print_message "Updating nvm …"

  git checkout --quiet master
  git pull --quiet --progress --tags

  local version
  version="$(nvm --version)"

  local latest
  latest="$(git describe --abbrev=0 --match "v[0-9]*" origin --tags)"

  if [[ "$version" == "$latest" ]]; then
    git checkout --quiet "${version}"
    print_success "nvm is already up-to-date."
    return 0
  fi

  git checkout --quiet --progress "${latest}" \
    && print_success "Updated nvm to version ${latest}"

  source "$NVM_DIR/nvm.sh"
}

#
# Update the Node.js
#
update_node() {
  cd -- "$NVM_DIR" 2>/dev/null || return 1

  function_exists "nvm" || source "$NVM_DIR/nvm.sh"
  print_message "Updating Node.js …"

  local version
  version="$(nvm current)"

  local latest
  latest="$(nvm version-remote --lts)"

  wait

  if [[ "$version" == "$latest" ]]; then
    print_success "Node.js is already up-to-date."
    return 0
  fi

  print_message "Upgrading Node.js from version ${version} to ${latest} …"
  nvm install "${latest}" & wait
  nvm install-latest-npm & wait
  print_success "Upgraded Node.js to version ${latest}."

  if confirm "Do you want to use version ${latest} of Node.js as your system default?"; then
    nvm alias default "${latest}"
    nvm use "${latest}"
    print_success "Using version ${latest} of Node.js as your new system default."
  fi
}

#
# Update the ruby version manager
#
update_rvm() {
  command_exists "rvm" || return 1

  print_message "Updating Ruby Version Manager …"

  local version
  version="$(rvm -v | cut -d ' ' -f 2)"

  local latest
  latest="$(curl -s --fail --location https://github.com/rvm/rvm/raw/master/VERSION)"

  wait

  if [[ "$version" == "$latest" ]]; then
    print_success "Ruby Version Manager is already up-to-date."
    return 0
  fi

  print_message "Upgrading Ruby Version Manager from version ${version} to ${latest} …"
  rvm get head
  rvm reload
  rvm get stable
  print_success "Upgraded Ruby Version Manager to version ${latest}."
}

#
# Update tmux plugin manager and installed plugins
#
update_tpm() {
  local tpm_path="${TMUX_PLUGIN_MANAGER_PATH:-$XDG_DATA_HOME/tmux/plugins}"

  [[ -d "$tpm_path/tpm" ]] || return 1

  print_message "Updating Tmux plugin manager …"
  cd "$tpm_path/tpm" || return 1
  git remote update >/dev/null

  local current
  current="$(git rev-parse "@")"

  local remote
  remote="$(git rev-parse "@{u}")"

  if [[ "$current" != "$remote" ]]; then
    git pull --quiet --progress && print_success "Updated Tmux plugin manager."
  else
    print_success "Tmux plugin manager is already up-to-date."
  fi

  print_message "Updating tmux plugins …"

  TMUX_PLUGIN_MANAGER_PATH="$tpm_path" "$tpm_path/tpm/bin/update_plugins" all >/dev/null \
    && print_success "Updated tmux plugins."
}

# (e) Cleanup Command --------------------------------------------------- {{{2

#
# Cleanup the current system
#
# usage: cleanup [<component>]
#
cleanup() {
  local -a components=("homebrew" "rvm")
  local -a queue=( "$@" )

  if (( $# == 0 )); then
    queue=( "${components[@]}" )
  fi

  for component in "${components[@]}"; do
    if function_exists "cleanup_${component}"; then
      "cleanup_${component}"
    else
      unknown_component "${component}"
    fi
  done
}

#
# Cleanup old versions of installed packages and prune dead symlinks.
#
cleanup_homebrew() {
  command_exists "brew" || return 1

  print_message "Removing old versions of installed formulae …"
  brew cleanup

  print_message "Removing dead symlinks …"
  brew prune
}

#
# Reclaim all of the space used by rvm archives, repository clones, source
# files and logs
#
cleanup_rvm() {
  command_exists "rvm" || return 1

  print_message "Cleaning up rvm resources …"
  rvm cleanup all
}



# (4) Entry Point ------------------------------------------------------- {{{1

#
# Main entry point of the script.
#
# usage: dotfiles <command>
#
main() {
  # Stop script execution, expect at least a command name
  if (( $# == 0)); then
    usage
    return 1
  fi

  # Run the given command
  local command="$1"
  shift

  case "$command" in
    cleanup) cleanup "$@" ;;
    help)    help "$@" ;;
    setup)   setup "$@" ;;
    update)  update "$@" ;;
    *)       command_not_found "$command" ;;
  esac
}

main "$@"



# vim:foldmethod=marker:foldlevel=2
