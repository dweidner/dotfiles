#!/usr/bin/env bash

#
# Options/Flags
#
# $DOTFILES_DIRECTORY         = Path of the local working copy.
# $DOTFILES_REMOTE_REPOSITORY = Name of the remote git repository.
# $INSTALL_NPM_PACKAGES       = Install list of npm packages
# $INSTALL_FORMULAE           = Install list of hombrew formulae
# $CREATE_SYMLINKS            = Create symbolic links to dotfiles
# $UPDATE_SUBMODULES          = Whether to update submodules or not
#

COLOR_FAIL="\e[1;31m"
COLOR_SUCCESS="\e[1;32m"
COLOR_WARN="\e[1;33m"
COLOR_RESET="\e[0m"

DOTFILES_DIRECTORY="$HOME/.dotfiles"
DOTFILES_REMOTE_REPOSITORY="dweidner/dotfiles"
INSTALL_NPM_PACKAGES=0
INSTALL_FORMULAE=0
CREATE_SYMLINKS=0
UPDATE_SUBMODULES=0
UPDATE_OSX_SETTINGS=0

#
# Tells users how to use the script.
#
# Usage: usage
#
usage() {
  cat <<EOT

Usage: dotfiles [-h] [-u] [-s] [-b] [-n] [-x] [-a]

Options:
   -h  Print usage information.
   -u  Update submodules installed with the repository.
   -s  Create symbolic links (may overwrite existing).
   -b  Install homebrew formulae.
   -n  Install npm packages.
   -x  Run script to customize OSX default settings.
   -a  Combine options [-u], [-s], [-b] and [-n]

Copyright (c) Daniel Weidner
Licensed under the MIT license.

EOT
}

#
# Check for the existiance of flags and update corresponding
# script variables.
#
# Usage: parse_options args
#
parse_options() {
  set -- "$@"

  local ARGN=$#
  while [ "$ARGN" -ne 0 ]; do
    case $1 in
      -h) usage
          exit 0
          ;;
      -u) UPDATE_SUBMODULES=1
          ;;
      -s) CREATE_SYMLINKS=1
          ;;
      -b) INSTALL_FORMULAE=1
          ;;
      -n) INSTALL_NPM_PACKAGES=1
          ;;
      -x) UPDATE_OSX_SETTINGS=1
          ;;
      -a) UPDATE_SUBMODULES=1
          UPDATE_OSX_SETTINGS=1
          CREATE_SYMLINKS=1
          INSTALL_FORMULAE=1
          INSTALL_NPM_PACKAGES=1
          ;;
      ?*) print_error "Unknown option."
          usage
          exit 0
          ;;
    esac
    shift
    ARGN=$((ARGN-1))
  done
}

#
# Test whether the given command can be executed.
#
# Usage: is_executable command
#
# $1 = Name of the command to execute.
#
is_executable() {
  test -x "$(command -v "$1")"
}

#
# Test if a homebrew formula is installed on the system.
#
# Usage: is_formula_installed formula
#
# $1 = Name of the homebrew formula.
#
is_formula_installed() {
  brew list "$1" >/dev/null 2>&1
}

#
# Test if xcode command line tools are installed. Note: Only works for OSX 10.9+.
#
# Usage: is_xcode_installed
#
is_xcode_installed() {
  [ "$(xcode-select -p >/dev/null; printf "%s" "$?")" -eq 0 ]
}

#
# Test if a given folder is a git repository.
#
# Usage: is_git_repository directory
#
# $1 = Path of the directory.
#
is_git_repository() {
  local dir="$1"

  # Ensure the specified directory exists
  if [[ ! -d "$dir" ]]; then
    return 1
  fi

  # Switch to the directory before running the git command
  pushd "$dir" >/dev/null

  # Test whether the current working directory is a git repository
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    popd >/dev/null
    return 0
  fi

  popd >/dev/null
  return 1
}

#
# Test whether the user confirmed a question asked via readline.
#
# Usage: is_confirmed
#
is_confirmed() {
  [[ "$REPLY" =~ ^[YyJj]$ ]]
}

#
# Create a symbolic link to a file in the dotfiles repository.
#
# Usage: link dotfile symlink
#
# $1 = Relative path to the file in the dotfiles repository.
# $2 = Relative path from the home directory.
#
link() {
  if [ -r "$DOTFILES_DIRECTORY/$1" ]; then
    ln -fs "$DOTFILES_DIRECTORY/$1" "$HOME/$2"
    return $?
  else
    print_error "Can not create a symbolic link to $1"
    return 1
  fi
}

#
# Strip comments and empty lines from a file.
#
# Usage: strip_comments file
#
# $1 = File to strip comments from.
#
strip_comments() {
  egrep -v "(^#|^$)" "$1"
}

#
# Print a status information.
#
# Usage: print_status message
#
# $1 = Message to print.
#
print_status() {
  printf "● %s\n" "$1"
}

#
# Print a error message.
#
# Usage: print_erro message
#
# $1 = Message to print.
#
print_error() {
  printf "%b⨯ ERROR: %b%s\n" "$COLOR_FAIL" "$COLOR_RESET" "$1"
}

#
# Print a warning message.
#
# Usage: print_warning message
#
# $1 = Message to print.
#
print_warning() {
  printf "%b▴ WARNING: %b%s\n" "$COLOR_WARN" "$COLOR_RESET" "$1"
}

#
# Notify user about a started process.
#
# Usage: process_started name [message]
#
#  $1  = Name of the process.
# [$2] = Optional debug message.
#
process_started() {
  local process="$1"
  local message="${2:-Processing...}"
  printf "● %s\n" "$message"
}

#
# Notify user about a finished process.
#
# Usage: process_done name [message]
#
#  $1  = Name of the process.
# [$2] = Optional debug message.
#
process_done() {
  # shellcheck disable=SC2034
  local process="$1"
  local message="${2:-Done.}"
  printf "%b✓ %s%b\n" "$COLOR_SUCCESS" "$message" "$COLOR_RESET"
}

#
# Notify user about an aborted process.
#
# Usage: process_aborted name [message]
#
#  $1  = Name of the process.
# [$2] = Optional debug message.
#
process_aborted() {
  # shellcheck disable=SC2034
  local process="$1"
  local message="${2:-Aborted.}"
  printf "%b⨯ %s%b\n" "$COLOR_FAIL" "$message" "$COLOR_RESET"
}

#
# Ask for user input.
#
# Usage: seek_confirmation question
#
# $1 = Question to ask.
#
seek_confirmation() {
  read -r -n 1 -p "● $* (y/n) "
  printf "\n"
}

#
# Reads the contents of a file containing a package list.
#
# Usage: read_package_list file
#
# $1 = Name of the package list to read.
#
read_package_list() {
  local filename="$1"
  local filepath="$HOME/.$filename"

  if [[ ! -f "$filepath" ]]; then
    filepath="$DOTFILES_DIRECTORY/misc/$filename"
  fi

  if [ -f "$filepath" ]; then
    strip_comments "$filepath"
  fi
}

#
# Download a compressed archive and extract it to a target
# directory.
#
# Usage: git_download_archive repository target
#
# $1 = Name of the repository to download.
# $2 = Target directory to copy the repository to.
#
git_download_archive() {
  local repository="$1"
  local target="$2"

  # Generate a unique name for the temporary archive
  local prefix
  prefix="$(basename "$0")"
  local tmpfile
  tmpfile="$(mktemp "/tmp/$prefix.tar.gz")"

  # Load and extract the repository
  curl -fsSLo "$tmpfile" "https://github.com/$repository/tarball/master"
  tar -zxf "$tmpfile" --strip-components 1 -C "$target"

  # Remove the archive
  rm -rf "$tmpfile"
}

#
# Initialize a given directory as git repository.
#
# Usage: git_initialize_repository dir [remote]
#
#  $1 = Directory to initialize as git repository.
# [$2] = Name of the remote repository.
#
git_initialize_repository() {
  local dir="$1"
  local remote_repository="$2"

  # Switch to the given directory
  pushd "$dir" >/dev/null

  # Initialize the current directory as git repository
  git init

  # Fetch the remote repository and cleanup local working tree
  if [ -n "$remote_repository" ]; then
    git remote add origin "git@github.com:$repository.git"
    git fetch origin master
    git reset --hard FETCH_HEAD
    git clean -fd
  fi

  # Switch back to the previous directory
  popd >/dev/null
}

#
# Run a bash function for each submodule.
#
# Usage: git_foreach_submodule fn
#
# $1 = Name of the function to run.
#
git_foreach_submodule() {
  local args=(-c "$1 \"\$@\"" "$1")

  # Export internal functions so we can use them within the
  # `git submodule foreach` loop
  # shellcheck disable=SC2163
  export -f "$1"

  # Run the specified script function foreach submodule
  # shellcheck disable=SC2016
  git submodule --quiet foreach --recursive 'echo "$name $path $toplevel"' | xargs -n3 -P20 sh "${args[@]}"

  # Remove the internal functions from the global scope
  # shellcheck disable=SC2163
  unset -f "$1"
}

#
# Display the status of the dotfiles repository and all its submodules.
#
# Usage: git_get_submodule_status name path toplevel
#
# $1 = Name of the submodule.
# $2 = Relative path to the submodule.
# $3 = Absolute path to the parent repository.
#
git_get_submodule_status() {
  local name="$1"
  local path="$2"
  local toplevel="$3"

  if [[ ! -d "$toplevel/$path" ]]; then
    return 1
  fi

  # Switch to the given directory
  pushd "$toplevel/$path" >/dev/null

  # Determine the current upstream branch and the corresponding sha
  local upstream_branch=""
  local upstream_branch_sha=""

  upstream_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null)"
  upstream_branch="${upstream_branch#refs/remotes/origin/}"
  [[ -z "$upstream_branch" ]] && upstream_branch="master"
  upstream_branch_sha="$(git rev-parse "refs/remotes/origin/$upstream_branch")"

  # Determine the url of the remote repository
  local remote_url=""
  local remote_repository=""
  remote_url="$(git config --get remote.origin.url)"
  remote_repository="${remote_url##*/}"
  remote_repository="${remote_repository%.git}"

  # Grab the latest changes. Perform an API request that ensures that the given
  # SHA matches the latest SHA of the upstream repository.
  local response=""
  response="$(curl --silent --max-time 3 --output /dev/null --write-out "%{http_code}" --header "Accept: application/vnd.github.chitauri-preview+sha" --header "If-None-Match: \"$upstream_branch_sha\"" "https://api.github.com/repos/$remote_repository/commits/$upstream_branch")"

  if [[ "$response" != "304" ]]; then
    git fetch --force --quiet origin "refs/heads/$upstream_branch:refs/remotes/origin/$upstream_branch"
  fi

  # Determine the status of the current repository
  local count=""
  local status=""

  count="$(git rev-list --count --left-right "refs/remotes/origin/$upstream_branch"...HEAD 2>/dev/null | tr -s '\t' '|')"

  case "$count" in

    # No upstream
    "") status="?";;

    # Equal
    "0|0") status="$(printf "±%.2d" "0")";;

    # Ahead
    "0|"*) status="$(printf "%+.2d" "${count#0|}")";;

    # Behind
    *"|0") status="$(printf "%+.2d" "-${count%|0}")";;

    # Diverged
    *) status="$(printf "%+.2d %+.2d" "-${count%|*}" "${count#*|}")";;

  esac

  # Switch back to the previous directory
  popd >/dev/null

  # Render the module status
  printf "%s %s\n" "$status" "$remote_repository"
}

#
# Display changes made in to the remote branch since the last pull.
#
# Usage: git_get_submodule_changes name path toplevel
#
# $1 = Name of the submodule.
# $2 = Relative path to the submodule.
# $3 = Absolute path to the parent repository.
#
git_get_submodule_changes() {
  local name="$1"
  local path="$2"
  local toplevel="$3"
  local changes=""

  # Determine changes made to the remote repository since the last pull
  pushd "$toplevel/$path" >/dev/null
  changes="$(git --no-pager log --oneline HEAD..origin)"
  popd >/dev/null

  if [ -n "$changes" ]; then
    printf "%s:\n%s\n\n" "$name" "$changes"
  fi
}

#
# Update all submodules of the given working copy.
#
# Usage: git_update_submodules dir
#
# $1 = Path of the working copy.
#
git_update_submodules() {
  local dir="$1"

  # Ensure that a valid directory was given
  if [[ ! -d "$dir" ]]; then
    return 1
  fi

  # Switch to the working copy
  pushd "$dir" >/dev/null

  # Pull remote changes
  git pull --quiet --rebase 2>/dev/null

  # Update the registered submodules to match what the superproject
  git submodule --quiet update --init --recursive

  # Fetch and merge updates from the remote repository for each submodule
  # shellcheck disable=SC2016
  git submodule --quiet foreach --recursive 'git pull --quiet origin $(git config -f "$toplevel/.gitmodules" "submodule.$name.branch" || echo "master")'

  # Revert the changes to the working directory
  popd >/dev/null
}

#
# Install the xcode command line tools.
#
# Usage: isntall_xcode
#
install_xcode() {
  # Determine version of Mac OSX
  local darwin_version=
  darwin_version="$(uname -r)"

  # Install the command line tools for OSX 10.9+.
  if (( ${darwin_version%%.*} > 12 )); then
    xcode-select --install
    return $?
  fi

  # Not so easy to install the command line tools automatically
  # for older versions of OSX
  return 1
}

#
# Install the dotfiles repository to the target directory.
#
# Usage: install_dotfiles path
#
# $1 = Name of the repository to load.
# $2 = Path to install the repository to.
#
install_dotfiles() {
  local repository="$1"
  local dir="$2"

  if [[ -z "$repository" || -z "$dir" ]]; then
    print_error "Invalid arguments given."
    return 1
  fi

  # Download and extract remote repository
  if [[ ! -d "$dir" ]]; then
    process_started "git_download_archive" "Downloading remote repository..."
    git_download_archive "$repository" "$dir"
    process_done "git_download_archive"
  fi

  # Setup archive as git repository...
  if ! is_git_repository "$dir"; then

    # Initialize repository and submodules
    process_started "git_initialize_repository" "Initializing git repository..."
    git_initialize_repository "$dir"
    process_done "git_initialize_repository"

    # Create symbolic links
    process_started "dotfiles_create_symlinks" "Creating symbolic links..."
    dotfiles_create_symlinks
    process_done "dotfiles_create_symlinks"

  fi

  # Test if installation was successfull
  [[ -d "$dir" && -z $(is_git_repository "$dir") ]]
}

#
# Installs a list of npm packages from a configuration file.
#
# Usage: install_homebrew_formulae
#
install_homebrew_formulae() {

  # Ensure homebrew is installed before installing formulae
  if ! is_executable "brew"; then

    # Offer to install homebrew
    seek_confirmation "Install homebrew the missing package manager for OSX?"

    if is_confirmed; then
      process_started "install_homebrew" "Installing homebrew package manager..."
      ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
      process_done "install_homebrew"
    else
      process_aborted "install_homebrew"
    fi

  fi

  # Read formula list into an array
  IFS=$'\r\n' GLOBIGNORE='*'
  local -a formulae=($(read_package_list "brewformulae"))
  unset IFS GLOBIGNORE

  # Install formulae in one go
  if [ ${#formulae[@]} -gt 0 ]; then

    # Collect missing formulae
    for formula in "${formulae[@]}"; do
      formula_args=($formula)
      if ! is_formula_installed "${formula_args[0]}"; then
        missing=("${missing[@]}" "$formula")
      fi
    done

    # Install missing formulae
    if [ ${#missing[@]} -gt 0 ]; then
      brew update
      brew upgrade
      brew install "${missing[@]}"
      brew cleanup
    fi
  else
    print_warning "No formular list found."
    return 1
  fi

  # Return the last exit code
  return $?
}

#
# Installs a list of npm packages from a configuration file.
#
# Usage: install_npm_packages
#
install_npm_packages() {

  # Ensure npm is installed before installing packages
  if ! is_executable "npm"; then

    # Offer to install npm
    seek_confirmation "The node package manager is not installed. Install now?"

    if is_confirmed; then
      process_started "install_npm" "Installing node package manager..."
      curl -L https://www.npmjs.com/install.sh | sh
      process_done "install_npm"
    else
      process_aborted "install_npm"
    fi

  fi

  # Read package list into an array
  IFS=$'\r\n' GLOBIGNORE='*'
  local -a packages=($(read_package_list "npmpackages"))
  unset IFS GLOBIGNORE

  # Install packages in one go
  if [ ${#packages[@]} -gt 0 ]; then
    npm install "${packages[@]}" --global --quiet
  else
    print_warning "No package list found."
    return 1
  fi

  # Return the last exit code
  return $?
}

#
# Display script header.
#
# Usage: dotfiles_show_header
#
dotfiles_show_header() {
  echo '                                     ';
  echo '    __| | ___ | |_ / _(_) | ___  ___ ';
  echo '   / _` |/ _ \| __| |_| | |/ _ \/ __|';
  echo '  | (_| | (_) | |_|  _| | |  __/\__ \';
  echo ' (_)__,_|\___/ \__|_| |_|_|\___||___/';
  echo '                                     ';
}

#
# Create symbolic links between configuration files of the dotfiles repository
# and files in the home directory.
#
# Usage: dotfiles_create_symlinks
#
dotfiles_create_symlinks() {
  # Copy `.gitconfig` if it does not exist
  [[ ! -f "$HOME/.gitconfig" ]] && cp "$DOTFILES_DIRECTORY/git/gitconfig" "$HOME/.gitconfig"

  # Create the necessary symbolic links between the `dotfiles` and `HOME`
  link "vim"                ".vim"
  link "shell/profile"      ".profile"
  link "shell/bash_profile" ".bash_profile"
  link "shell/bashrc"       ".bashrc"
  link "shell/inputrc"      ".inputrc"
  link "shell/dircolors"    ".dircolors"
  link "zsh/zprofile"       ".zprofile"
  link "zsh/zshrc"          ".zshrc"
  link "git/gitattributes"  ".gitattributes"
  link "git/gitignore"      ".gitignore"
  link "tmux/tmux.conf"     ".tmux.conf"
  link "misc/gemrc"         ".gemrc"
  link "misc/npmrc"         ".npmrc"
  link "misc/ctags"         ".ctags"
  link "misc/agignore"      ".agignore"
  link "misc/eslintrc"      ".eslintrc"

  # Avoid creating symbolic links twice
  CREATE_SYMLINKS=0
}

#
# Display the status of all submodules added to the dotfiles repository.
#
# Usage: dotfiles_show_status dir
#
# $1 = Path to the working tree.
#
dotfiles_show_status() {
  local dir="$1"
  local status=""
  local num_submodules=0
  local pending_updates=0

  # Switch to the given directory
  pushd "$dir" >/dev/null

  # Determine the total number of submodules.
  num_submodules="$(git submodule status 2>/dev/null | wc -l | tr -d '[:space:]')"

  if [ "$num_submodules" -eq 0 ]; then
    print_warning "No submodules found."
    return 0
  fi

  # Print user information
  print_status "$(printf "Fetching updates for %s submodules...\n" "$num_submodules")"

  # Determine the status of each submodule.
  status="$(git_foreach_submodule "git_get_submodule_status" | grep "^-")"

  # Switch back to the previous directory
  popd >/dev/null

  # Only show submodules which are behind the upstream
  if [ -n "$status" ]; then

    # Count the total number of modules that require an update
    pending_updates="$(echo -ne "$status" | wc -l |  tr -d '[:space:]')"

    # Summarize the modules with pending updates
    if [ "$pending_updates" -gt 0 ]; then
      print_status "$(printf "Updates available for %s of %s submodules:\n%s\n\n" "$pending_updates" "$num_submodules" "$status")"
      return "$pending_updates"
    fi

  fi

  print_status "All submodules are up to date."
  return 0
}

#
# List changes made to the remote repositories of all added submodules.
#
# Usage: dotfiles_list_updates dir
#
# $1 = Path to the working tree.
#
dotfiles_list_updates() {
  local dir="$1"
  local changes=""

  # Switch to the given directory
  pushd "$dir" >/dev/null

  # Retrieve the commit messages of the latest updates
  changes="$(git_foreach_submodule "git_get_submodule_changes")"

  # Switch back to the previous directory
  popd >/dev/null

  # Output changes if any are available
  if [ -n "$changes" ]; then
    printf "\n%b\n\n" "$changes" | less
  fi
}

#
# Script entry point
#
main() {
  # Handle script options
  parse_options "$@"

  # Render the script header
  dotfiles_show_header

  # Install XCode
  if ! is_xcode_installed; then
    print_warning "The XCode Command Line Tools must be installed first."
    process_started "install_xcode" "Installing XCode Command Line Tools..."
    if ! install_xcode; then
      print_error "Could not install XCode Command Line Tools. Please install the Command Line Tools manually: https://developer.apple.com/downloads"
      exit 1
    fi
    process_done "insall_xcode"
  fi

  # Install the repository if not already done
  if ! install_dotfiles "$DOTFILES_REMOTE_REPOSITORY" "$DOTFILES_DIRECTORY"; then
    print_error "Could not install dotfiles."
    return 1
  fi

  # Display the status of submodules added to the repository
  if ! dotfiles_show_status "$DOTFILES_DIRECTORY"; then
    print_status "Found udpdates for at leas one submodule."

    # Ask if the users wants to show the changes
    seek_confirmation "Do you want to list the changes made to the remote repositories of your submodules?"

    if is_confirmed; then
      dotfiles_list_updates "$DOTFILES_DIRECTORY"
    else
      process_aborted "dotfiles_list_updates"
    fi

    # Ask if the users wants to integrate submodule updates
    seek_confirmation "Do you want to integrate the latest changes into your working copy?"

    if is_confirmed; then
      UPDATE_SUBMODULES=1
    else
      UPDATE_SUBMODULES=0
      process_aborted "git_update_submodules"
    fi
  fi

  # Update all dependencies added as submodules to the project
  if [ "$UPDATE_SUBMODULES" -eq 1 ]; then
    process_started "git_update_submodules" "Updating submodules..."
    if ! git_update_submodules "$DOTFILES_DIRECTORY"; then
      print_error "Could not update submodules."
      return 1
    fi
    process_done "git_update_submodules"
  fi

  # Create symbolic links if desired
  if [ "$CREATE_SYMLINKS" -eq 1 ]; then
    process_started "dotfiles_create_symlinks" "Creating symbolic links..."
    dotfiles_create_symlinks
    process_done "dotfiles_create_symlinks"
  fi

  # Install all npm packages specified in a configuration file
  if [ "$INSTALL_NPM_PACKAGES" -eq 1 ]; then
    process_started "install_npm_packages" "Installing npm packages..."
    if ! install_npm_packages; then
      print_error "Could not install npm packages."
      return 1
    fi
    process_done "install_npm_packages"
  fi

  # Install all homebrew formulae specified in a configuration file
  if [ "$INSTALL_FORMULAE" -eq 1 ]; then
    process_started "install_homebrew_formulae" "Installing hombrew formulae..."
    if ! install_homebrew_formulae; then
      print_error "Could not install homebrew formulae."
      return 1
    fi
    process_done "install_homebrew_formulae"
  fi

  # Run osxdefaults by Mathias Bynens
  if [ "$UPDATE_OSX_SETTINGS" -eq 1 ]; then
    seek_confirmation "Do you want to customize the OSX settings?"

    if is_confirmed; then
      process_started "osxdefaults" "Setting OSX defaults..."
      sh "$DOTFILES_DIRECTORY/bin/osxdefaults"
      process_done "osxdefaults"
    else
      process_aborted "osxdefaults"
    fi
  fi

  return 0
}

main "$@"
