#!/usr/bin/env bash
#
# @file Custom wrapper for frequently used docker services

# (1) Global Variables -------------------------------------------------- {{{1

export WWWUSER="${WWWUSER:-$UID}"
export WWWGROUP="${WWWGROUP:-$(id -g)}"

if [[ -f "./.env" ]]; then
  source "./.env"
fi



# (2) Utility Functions ------------------------------------------------- {{{1

#
# Determine whether docker is running
#
# usage: is_docker_running
#
is_docker_running() {
  docker info >/dev/null 2>&1
}

#
# Determine if any services are running
#
# usage: is_any_service_running
#
is_any_service_running() {
  docker compose ps --status running --services >/dev/null 2>&1
}

#
# Determine whether a docker compose service is running.
#
# usage: is_service_running <service>
#
is_service_running() {
  docker compose ps --status running --services "${1}" 2>/dev/null | grep --quiet "${1}"
}

#
# Determine whether a docker container is running.
#
# usage: is_container_running <container>
#
is_container_running() {
  docker ps --quiet --filter "name=${1}" >/dev/null
}

#
# Determine whether a command with the given name exists in the current
# environment.
#
# usage: command_exists <name>
#
command_exists() {
  command -v "${1}" >/dev/null 2>&1
}

#
# Determine whether a container exists.
#
# usage: container_exists <name>
#
container_exists() {
  docker container inspect "${1}" >/dev/null 2>&1
}

#
# Determine whether a docker network exists.
#
# usage: network_exists <name>
#
network_exists() {
  docker network inspect "${1}" >/dev/null 2>&1
}

#
# Print a status message.
#
# usage: print_message <message>
#
print_message() {
  echo -e "\\033[0;34m==> $*\\033[0;m"
}

#
# Print an error message.
#
# usage: print_error <message>
#
print_error() {
  echo -e "\\033[0;31m==> $*\\033[0;m" >&2
}

#
# Print a warning message.
#
# usage: print_warning <message>
#
print_warning() {
  echo -e "\\033[0;33m==> $*\\033[0;m" >&2
}

#
# Confirm a question with the user.
#
# usage: confirm <question>
#
confirm() {
  read -r -p $'\e[0;32m'"==> $* (y/n [n]) "$'\e[0;m' answer

  case "$answer" in
    y|Y) return 0 ;;
    *) return 1 ;;
  esac
}

#
# Get the name of the current docker compose project.
#
# usage: project_name
#
project_name() {
  if [[ -n "${COMPOSE_PROJECT_NAME}" ]]; then
    printf '%s\n' "${COMPOSE_PROJECT_NAME}"
  else
    printf '%s\n' "${PWD##*/}"
  fi
}

#
# Find the first service of multiple candidates that is currently running.
#
# usage: find_service <service> [service] [service] …
#
find_service() {
  for service in "${@}"; do
    if is_service_running "${service}"; then
      echo "${service}"
      return 0
    fi
  done

  return 1
}



# (3) Commands ---------------------------------------------------------- {{{1

# (a) Usage Command ----------------------------------------------------- {{{2

#
# Display usage information.
#
usage() {
  cat <<- CommandUsage
		Dockr v1.0.0

    Execute frequently used commands in the corresponding Docker Compose
    services.

		Usage:
		dockr <command> [options] [arguments]

		Commands:
		  up        Start all containers of the current project.
		  down      Stop all containers of the current project.
		  restart   Restart all containers of the current project.
      proxy     Start a reverse proxy.
		  node      Run a Node command.
		  npm       Run a npm command.
		  npx       Run a npx command.
		  php       Run a snippet of PHP code.
		  composer  Run a Composer command.
		  artisan   Run an Artisan command.
		  drupal    Run a Drupal Console command.
		  drush     Run a Drush command.
		  phpunit   Run a PHPUnit test.
		  mysql     Start a MYSQL CLI session.
	CommandUsage
}

# (b) Start Command ----------------------------------------------------- {{{2

#
# Start all containers of the current docker compose project.
#
# usage: start_services
#
start_services() {
  if is_any_service_running; then
    print_warning "Some Docker containers are already running"

    if confirm "Do you want to shut them down first?"; then
      stop_services
    fi
  fi

  docker compose up --detach --wait
}

# (c) Stop Command ------------------------------------------------------ {{{2

#
# Stop all containers of the current docker compose project.
#
# usage: stop_services
#
stop_services() {
  docker compose down --remove-orphans
}

# (d) Proxy Command ----------------------------------------------------- {{{2

#
# Start a reverse proxy for local development using traefik.
#
# usage: start_proxy [<container>] [<network>]
start_proxy() {
  local config_dir="${XDG_CONFIG_HOME:-$HOME/.config}"

  local container_name="${1:-traefik}"
  local network_name="${2:-$container_name}"

  print_message "Starting reverse proxy …"

  if ! network_exists "${network_name}"; then
    docker network create \
      --driver bridge \
      --attachable \
      "${network_name}" >/dev/null

    print_message "Created external network."
  fi

  if ! container_exists "${container_name}"; then
    print_message "Creating traefik container …"

    docker create \
      --publish "80:80" \
      --publish "8080:8080" \
      --publish "443:443" \
      --volume "/var/run/docker.sock:/var/run/docker.sock:ro" \
      --volume "${config_dir}/traefik/:/etc/traefik" \
      --name "${container_name}" \
      --network "${network_name}" \
      --restart "unless-stopped" \
      traefik:latest \
      --providers.docker \
      --prodiders.docker.network="${network_name}" >/dev/null

    if (( $? > 0 )); then
      print_error "Could not create traefik container."
    else
      print_message "Traefik container created."
    fi
  fi

  if ! is_container_running "${container_name}"; then
    docker start "${container_name}" >/dev/null
    print_message "Traefik started (http://localhost:8080)."
  else
    docker restart "${container_name}" >/dev/null
    print_message "Traefik container restarted (http://localhost:8080)."
  fi
}


# (4) Entry Point ------------------------------------------------------- {{{1

#
# Main entry point of the script.
#
# usage: dockr [<cmd>] [options] [arguments]
#
main() {
  if ! command_exists "docker"; then
    print_error "Command [docker] is not defined"
    return 1
  fi

  if ! is_docker_running; then
    print_warning "Docker is not running"
    return 1
  fi

  local options=()

  if [[ ! -t 0 ]]; then
    options+=(--no-TTY)
  fi

  for option in "$@"; do
    case "${option}" in
      -e|--env)
        options+=(--env "${2}")
        shift 2
        ;;
      -u|--user)
        options+=(--user "${2}")
        shift 2
        ;;
    esac
  done

  local command="${1}"
  shift 1

  local project
  project="$(project_name)"

  local node_service
  node_service="$(find_service "node" "laravel" "${APP_SERVICE:-laravel.test}")"

  local php_service
  php_service="$(find_service "php" "drupal" "wordpress" "laravel" "${APP_SERVICE:-laravel.test}")"

  local mysql_service
  mysql_service="$(find_service "db" "mysql" "mariadb")"

  case "${command}" in
    help)
      usage
      ;;
    ls|list)
      list_projects
      ;;
    up)
      start_services
      ;;
    down)
      stop_services
      ;;
    restart)
      stop_services
      start_services
      ;;
    proxy)
      start_proxy
      ;;
    ruby)
      docker compose exec "${options[@]}" "${ruby_service:-ruby}" \
        ruby "${@}"
      ;;
    bundle)
      docker compose exec "${options[@]}" "${ruby_service:-ruby}" \
        bundle "${@}"
      ;;
    gem)
      docker compose exec "${options[@]}" "${ruby_service:-ruby}" \
        gem "${@}"
      ;;
    node)
      docker compose exec "${options[@]}" "${node_service:-node}" \
        node "${@}"
      ;;
    npm)
      docker compose exec "${options[@]}" "${node_service:-node}" \
        npm "${@}"
      ;;
    npx)
      docker compose exec "${options[@]}" "${node_service:-node}" \
        npx "${@}"
      ;;
    php)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        php "${@}"
      ;;
    composer)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        composer "${@}"
      ;;
    artisan)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        php artisan "${@}"
      ;;
    drupal)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        ./vendor/bin/drupal "${@}"
      ;;
    drush)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        ./vendor/bin/drush "${@}"
      ;;
    phpunit)
      docker compose exec "${options[@]}" "${php_service:-php}" \
        ./vendor/bin/phpunit "${@}"
      ;;
    sql)
      docker compose exec "${options[@]}" "${mysql_service:-mysql}" \
        bash -c "MYSQL_PWD=\${MYSQL_PASSWORD} mysql -u \${MYSQL_USER} \${MYSQL_DATABASE}"
      ;;
    sql:dump)
      local today
      today="$(date +%Y-%m-%d)"

      local file
      file="/docker-entrypoint-initdb.d/${1:-${today}-${project}.sql}"

      docker compose exec "${options[@]}" "${mysql_service:-mysql}" \
         bash -c "MYSQL_PWD=\${MYSQL_PASSWORD} mysqldump -u \${MYSQL_USER} \${MYSQL_DATABASE} -r \"${file}\""
      ;;
    sql:restore)
      local input

      if (( $# > 0 )); then
        input="/docker-entrypoint-initdb.d/$*"
      else
        input="/dev/stdin"
      fi

      docker compose exec "${options[@]}" "${mysql_service:-mysql}" \
        bash -c "MYSQL_PWD=\${MYSQL_PASSWORD} mysql -u \${MYSQL_USER} \${MYSQL_DATABASE} < \"${input}\""
      ;;
    *)
      print_error "Unknown command [${command}]"
      usage
      ;;
  esac
}

main "$@"



# vim:foldmethod=marker:foldlevel=2
