#!/usr/bin/env bash
#
# @file Custom wrapper for frequently used docker services

# (1) Global Variables -------------------------------------------------- {{{1

export WWWUSER="${WWWUSER:-$UID}"
export WWWGROUP="${WWWGROUP:-$(id -g)}"

if [[ -f "./.env.local" ]]; then
  source "./.env.local"
elif [[ -f "./.env" ]]; then
  source "./.env"
fi



# (2) Utility Functions ------------------------------------------------- {{{1

#
# Determine whether docker is running
#
# usage: is_docker_running
#
is_docker_running() {
  docker info >/dev/null 2>&1
}

#
# Determine whether a command with the given name exists in the current
# environment.
#
# usage: command_exists <name>
#
command_exists() {
  command -v "${1}" >/dev/null 2>&1
}

#
# Print a status message.
#
# usage: print_message <message>
#
print_message() {
  echo -e "\\033[0;34m==> $*\\033[0;m"
}

#
# Print an error message.
#
# usage: print_error <message>
#
print_error() {
  echo -e "\\033[0;31m==> $*\\033[0;m" >&2
}

#
# Print a warning message.
#
# usage: print_warning <message>
#
print_warning() {
  echo -e "\\033[0;33m==> $*\\033[0;m" >&2
}

#
# Confirm a question with the user.
#
# usage: confirm <question>
#
confirm() {
  read -r -p $'\e[0;32m'"==> $* (y/n [n]) "$'\e[0;m' answer

  case "$answer" in
    y|Y) return 0 ;;
    *) return 1 ;;
  esac
}

#
# Get the name of the current docker compose project.
#
# usage: get_project_name
#
get_project_name() {
  local project_root
  project_root="$(get_project_root)"

  if [[ -n "${COMPOSE_PROJECT_NAME}" ]]; then
    printf '%s\n' "${COMPOSE_PROJECT_NAME}"
  else
    printf '%s\n' "${project_root##*/}" | sed -E 's/[^a-zA-Z0-9]+/-/g'
  fi
}

#
# Get the path to the root directory of the current project.
#
# usage: get_project_root
#
get_project_root() {
  if command_exists "git"; then
    git rev-parse --show-toplevel
  else
    pwd
  fi
}

#
# Get the path to the configuration file of the docker compose project.
#
# usage: get_project_config
#
get_project_config() {
  local project_root
  project_root="$(get_project_root)"

  local ddev_configuration=(
    "${PWD}/.ddev/.ddev-docker-compose-full.yaml"
    "${project_root}/.ddev/.ddev-docker-compose-full.yaml"
  )

  for file in "${ddev_configuration[@]}"; do
    if [[ -r "${file}" ]]; then
      echo "${file}"
      return 0
    fi
  done

  local docker_configuration=(
    "${PWD}/compose.yml"
    "${PWD}/docker-compose.yml"
    "${project_root}/compose.yml"
    "${project_root}/docker-compose.yml"
  )

  for file in "${docker_configuration[@]}"; do
    if [[ -r "${file}" ]]; then
      echo "${file}"
      return 0
    fi
  done

  return 1
}



# (3) Entry Point ------------------------------------------------------- {{{1

#
# Help text for custom command
#
# usage: help
#
help() {
  cat <<- CommandUsage
		Dockr v1.0.0

    Execute frequently used commands in the corresponding Docker Compose
    services.

		Usage:
		dockr <command> [options] [arguments]

		Commands:
		  up        Start all containers of the current project.
		  down      Stop all containers of the current project.
		  restart   Restart all containers of the current project.
		  node      Run a Node command.
		  npm       Run a npm command.
		  npx       Run a npx command.
		  php       Run a snippet of PHP code.
		  composer  Run a Composer command.
		  artisan   Run an Artisan command.
		  drupal    Run a Drupal Console command.
		  drush     Run a Drush command.
		  phpunit   Run a PHPUnit test.
	CommandUsage
}

#
# Main entry point of the script.
#
# usage: dockr [options] [<cmd>] [arguments]
#
main() {
  if ! command_exists "docker"; then
    print_error "Command [docker] is not defined"
    return 1
  fi

  if ! is_docker_running; then
    print_error "Docker is not running"
    return 1
  fi

  local project_name
  project_name="$(get_project_name)"

  if [[ -z "${project_name}" ]]; then
    print_warning "Could not determine project name"
    return 1
  fi

  local project_config
  project_config="$(get_project_config)"

  if [[ ! -r "${project_config}" ]]; then
    print_warning "Docker compose configuration not found"
    return 1
  fi

  local compose_options=(--project-name "${project_name}")
  compose_options+=(--project-name "${project_name}")
  compose_options+=(--file "${project_config}")

  local compose_services
  compose_services="$(docker compose "${compose_options[@]}" config --services 2>/dev/null)"

  if [[ -z "${compose_services}" ]]; then
    print_warning "Inalid docker compose configuration"
    return 1
  fi

  local command="${1}"
  shift 1

  local command_options=()

  for command_option in "$@"; do
    case "${command_option}" in
      -e|--env)
        command_options+=(--env "${2}")
        shift 2
        ;;
      -u|--user)
        command_options+=(--user "${2}")
        shift 2
        ;;
    esac
  done

  local php_service

  for service_name in "php" "web" "${APP_SERVICE:-laravel.test}"; do
    if grep -q -E "\b${service_name}\b" <<< "${compose_services}"; then
      php_service="${service_name}"
      break
    fi
  done

  local node_service

  for service_name in "node" "web" "${APP_SERVICE:-laravel.test}"; do
    if grep -q -E "\b${service_name}\b" <<< "${compose_services}"; then
      node_service="${service_name}"
      break
    fi
  done

  case "${command}" in
    help)
      help
      ;;
    up)
      docker compose "${compose_options[@]}" up "${@}"
      ;;
    down)
      docker compose "${compose_options[@]}" down "${@}"
      ;;
    config)
      docker compose "${compose_options[@]}" config "${@}"
      ;;
    restart)
      docker compose "${compose_options[@]}" restart "${@}"
      ;;
    ruby|bundle|gem)
      docker compose "${compose_options[@]}" exec "${command_options[@]}" "${ruby_service:-ruby}" \
        "${command}" "${@}"
      ;;
    node|npm|npx)
      docker compose "${compose_options[@]}" exec "${command_options[@]}" "${node_service:-node}" \
        "${command}" "${@}"
      ;;
    php|composer)
      docker compose "${compose_options[@]}" exec "${command_options[@]}" "${php_service:-php}" \
        php "${@}"
      ;;
    artisan)
      docker compose "${compose_options[@]}" exec "${command_options[@]}" "${php_service:-php}" \
        php artisan "${@}"
      ;;
    phpunit|phpcs|phpstan|pint|drupal|drush|kirby|wp)
      docker compose "${compose_options[@]}" exec "${command_options[@]}" "${php_service:-php}" \
        "./vendor/bin/${command}" "${@}"
      ;;
    *)
      print_error "Unknown command [${command}]"
      help
      ;;
  esac
}

main "$@"



# vim:foldmethod=marker:foldlevel=2
