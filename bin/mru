#!/usr/bin/env bash

#
# Options/Flags
#
# $REVERSE_ORDER     = Reverse the order of the file list
# $LONG_LIST         = Display detailed file information
# $PRETTY_PRINT      = Improve the readability of the generated list
# $USE_CREATION_DATE = Use the creation date instead of the last modified time
#

REVERSE_ORDER=0
LONG_LIST=0
PRETTY_PRINT=0
USE_CREATION_DATE=0

#
# Display usage information.
#
# Usage: usage
#
usage() {
  cat <<EOT

Usage: mru [-c] [-e cmd] [-h] [-l] [-r]

Options:
  -c  Use the creation date instead of the time last modified
  -e  Execute the given command passing the most recently used file as argument
  -h  Print usage information
  -l  Display detailed file information
  -p  Improve readability of the generated output
  -r  Reverse order of the file list

Copyright (c) Daniel Weidner
Licensed under the MIT license.

EOT
}

#
# Check for the existiance of flags and update corresponding
# script variables.
#
# Usage: parse_options args
#
parse_options() {
  set -- "$@"

  local argn=$#
  while [ "$argn" -ne 0 ]; do
    case $1 in
      -h) usage
          exit 0
          ;;
      -c) USE_CREATION_DATE=1
          ;;
      -e) open_latest "$2"
          exit 0
          ;;
      -l) LONG_LIST=1
          ;;
      -r) REVERSE_ORDER=1
          ;;
      -p) PRETTY_PRINT=1
          ;;
      ?*) printf "Unknown option %s.\n" "$1"
          usage
          exit 0
    esac
    shift
    ((argn--))
  done
}

#
# Try to test whether the given file is a valid viminfo file.
# Not really bullet-proof as the function only ensures that
# the given file with the expected comment section in the
# header.
#
# Usage: is_viminfo_file file
#
# $1 = Path to the file to test.
#
is_viminfo_file() {
  local line
  line="$(head -n1 "$1")"
  [[ "$line" =~ "# This viminfo file was generated by Vim"* ]]
}

#
# Throw exception and exit script
#
# Usage: throw msg
#
# $1 = Message to return.
#
throw() {
  printf "mru: %s\n" "$1"
  exit 1
}

#
# Strip comments and empty lines from a file.
#
# Usage: strip_comments file
#
# $1 = File to strip comments from.
#
strip_comments() {
  egrep -v "(^#|^$)" "$1"
}

#
#
# Sort the contents of the file by the value of the first column.
#
# Usage: sort_file_contents file
#
# $1 = Path to the file to sort.
#
sort_file_contents() {
  local sort_args=( -k1 )

  if [ "$REVERSE_ORDER" -eq "0" ]; then
    sort_args+=( -r )
  fi

  sort "${sort_args[@]}" "$1" -o "$1"
}

# Open the most recently used file within the given application.
#
# Usage: open_latest [command]
#
# $1 = Name of the command to open the file with.
#
open_latest() {
  # shellcheck disable=SC2155
  local file="$(mru | head -n1)"
  local cmd="${1:-$EDITOR}"

  # Replace the tilde character with the path to the current home directory
  file="${file/#\~/$HOME}"

  # Open the file in the given application
  if [ -f "$file" ]; then
    "$cmd" "$file"
  fi
}

#
# Locate the file that should be used to extract the most recently used files.
#
# Usage: locate_mru_file
#
locate_mru_file() {
  local -a files

  files[0]="$HOME/.vim/tmp/ctrlp/mru/cache.txt"
  files[1]="$HOME/.cache/ctrlp/mru/cache.txt"
  files[2]="$HOME/.vim/tmp/viminfo"
  files[3]="$HOME/.viminfo"

  for file in "${files[@]}"; do
    if [ -f "$file" ]; then
      echo "$file"
      return 0
    fi
  done

  return 1
}

#
# Extract the files most recently used in vim/gvim/mvim.
#
# Usage: read_mru_file
#
read_mru_file() {
  # Find the file that should be used to extract the mru files from
  # shellcheck disable=SC2155
  local file="$(locate_mru_file)"

  if [[ ! -f "$file" ]]; then
    return 1
  fi

  # Read the file contents of the mru file
  if is_viminfo_file "$file"; then
    grep "^>" "$file" | cut -c3- | sort | uniq
  else
    strip_comments "$file"
  fi

  return 0
}

#
# Script entry point
#
main() {
  # Parse options
  parse_options "$@"

  # Determine which meta information to use as sort order
  local stat_args=()
  local stat_format=""

  if stat -c 2>/dev/null; then
    (( USE_CREATION_DATE )) && stat_format="%W" || stat_format="%Y"
    stat_args+=( -c "$stat_format" )
  else
    (( USE_CREATION_DATE )) && stat_format="%B" || stat_format="%m"
    stat_args+=( -f "$stat_format" )
  fi

  # Retrieve a list of files recently used
  # shellcheck disable=SC2155
  local files="$(read_mru_file)"

  if [ -z "$files" ]; then
    throw "Empty or invalid file list"
  fi

  # Just render the list of files
  if [ $PRETTY_PRINT -eq 0 ]; then
    echo "${files//\~/$HOME}"
    return 0
  fi

  # Generate a temporary file that holds the meta information required
  # for the sorting process.
  # shellcheck disable=SC2155
  local tmpfile="$(mktemp -t "$(basename "$0").XXXXXXXXXX")"

  while IFS=$'\r\n' read -r file; do
    file="${file/#\~/$HOME}"
    if [ -f "$file" ]; then
      printf "%s\t%s\n" "$(stat "${stat_args[@]}" "$file")" "$file" >> "$tmpfile"
    fi
  done <<< "$files"

  # Sort the contents of the temporary file by the value of the first column
  sort_file_contents "$tmpfile"

  # Output the list of most recently used files in the desired order
  if (( LONG_LIST )); then
    cut -f 2 "$tmpfile" | xargs ls -lalhF | sed "s@$HOME/@~/@g"
  else
    cut -f 2 "$tmpfile" | sed "s@^$HOME/@~/@"
  fi

  # Remove the temporary file used
  rm "$tmpfile"

  return 0
}

main "$@"
