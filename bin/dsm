#!/usr/bin/env bash
#
# @file Proxy command executions to running docker containers.

#
# Determine whether docker is running
#
# usage: is_docker_running
#
is_docker_running() {
  docker info >/dev/null 2>&1
}

#
# Determine whether a service container is running.
#
# usage: is_service_running <name>
#
is_service_running() {
  compose ps --status running --services 2>/dev/null | grep -q -E "\b${1}\b"
}

#
# Determine whether a service container exists in the current project.
#
# usage: service_exists <name>
#
service_exists() {
  compose config --services 2>/dev/null | grep -q -E "\b${1}\b"
}

#
# Determine whether a command with the given name exists in the current
# environment.
#
# usage: command_exists <name>
#
command_exists() {
  command -v "${1}" >/dev/null 2>&1
}

#
# Search for a file in the parent directories.
#
# usage: find_up <file> [<directory>]
#
find_up() {
  local file="${1}"
  local current_directory="${2:-$PWD}"

  while [[ "${current_directory}" != "/" ]]; do
    if [[ -r "${current_directory}/${file}" ]]; then
      echo "${current_directory}/${file}"
      return 0
    fi
    current_directory="$(dirname "${current_directory}")"
  done

  return 1
}

#
# Get the path to the root directory of the current project.
#
# usage: find_root [<directory>]
#
find_root() {
  local working_dir="${1:-$PWD}"

  local project_markers=(
    "composer.json"
    "package.json"
    ".git"
    ".ddev"
    ".vscode"
    ".editorconfig"
  )

  local marker_name
  local marker_file

  for marker_name in "${project_markers[@]}"; do
    marker_file="$(find_up "${marker_name}" "${working_dir}")"

    if [[ -r "${marker_file}" ]]; then
      dirname "${marker_file}"
      return 0
    fi
  done

  return 1
}

#
# Get the path to the docker compose configuration.
#
# usage: find_config [<directory>]
#
find_config() {
  local working_dir="${1-:$PWD}"

  local config_files=(
    "${working_dir}/.ddev/.ddev-docker-compose-full.yaml"
    "${working_dir}/compose.yml"
    "${working_dir}/compose.yaml"
    "${working_dir}/docker-compose.yml"
    "${working_dir}/docker-compose.yaml"
  )

  local config_file

  for config_file in "${config_files[@]}"; do
    if [[ -r "${config_file}" ]]; then
      echo "${config_file}"
      return 0
    fi
  done

  return 1
}

#
# Find the first service container that exists in the current project.
#
# usage: find_service <name> [<name>] [â€¦]
#
find_service() {
  local service_name

  for service_name in "${@}"; do
    if service_exists "${service_name}"; then
      echo "${service_name}"
      return 0
    fi
  done

  return 1
}

#
# Initialize a project.
#
# usage: init <type>
#
init() {
  local type="${1}"

  if [[ -z "${type}" ]]; then
    echo "Project type is missing" >&2
    return 1
  fi

  local templates=(
    ["node"]="872f426e784a08e5e591096d5e9e6df4/archive/f76e94688793313030b3ec4bf83b9c75a9e3348e.zip"
    ["ruby"]="4dc038da8ba946a534ae2ee813a3df5e/archive/820b65f83ce2d48e1a5ddeb52cbbdc84632f415f.zip"
  )

  if [[ -z "${templates[$type]}" ]]; then
    echo "Unsupported project type [${type}]" >&2
    return 1
  fi

  local project_directory
  project_directory="$(find_root "${PWD}")"

  if [[ ! -d "${project_directory}" ]]; then
    echo "Could not determine project directory" >&2
    return 1
  fi

  local template_file="${templates[$type]}"
  local template_url="https://gist.github.com/dweidner/${template_file}"

  local tmp_file
  tmp_file="$(mktemp "${TMPDIR:-/tmp/}${type}.XXXXXXXXXXXX")"

  if ! wget -q -O "${tmp_file}" "${template_url}"; then
    echo "Could not download project template" >&2
    return 1
  fi

  if ! unzip -qnj -d "${project_directory}" "${tmp_file}"; then
    echo "Could not extract project template" >&2
    return 1
  fi

  if [[ -f "${tmp_file}" ]]; then
    rm "${tmp_file}"
  fi

  return 0
}

#
# Run docker compose in the current project.
#
# usage: compose <command>
#
compose() {
  if ! command_exists "docker"; then
    echo "Command [docker] is not defined" >&2
    return 1
  fi

  if ! is_docker_running; then
    echo "Docker is not running" >&2
    return 1
  fi

  local project_directory
  project_directory="$(find_root "${PWD}")"

  if [[ ! -d "${project_directory}" ]]; then
    echo "Could not determine project directory" >&2
    return 1
  fi

  local config_file
  config_file="$(find_config "${project_directory}")"

  if [[ ! -r "${config_file}" ]]; then
    echo "Docker compose configuration not found" >&2
    return 1
  fi

  if [[ -r "${project_directory}/.env.local" ]]; then
    source "${project_directory}/.env.local"
  elif [[ -r "${project_directory}/.env" ]]; then
    source "${project_directory}/.env"
  fi

  docker compose \
    --project-directory "${project_directory}" \
    --file "${config_file}" \
    "${@}"
}

#
# Run a command in a given service container.
#
# usage: run <service> <command> [<options>] [<arguments>]
#
run() {
  local fallback_services=()
  local fallback_service=

  local service_name="${1}"

  case "${service_name}" in
    app)
      fallback_services+=("laravel.test" "web")
      ;;
    node)
      fallback_services+=("laravel.test" "app" "web")
      ;;
    php)
      fallback_services+=("laravel.test" "app" "web")
      ;;
    ruby)
      fallback_services+=("app" "web")
      ;;
  esac

  if ! service_exists "${service_name}" ; then
    fallback_service="$(find_service "${fallback_services[@]}")"

    if [[ -z "${fallback_service}" ]]; then
      echo "Service container does not exist [${service_name}]" >&2
      return 1
    fi

    service_name="${fallback_service}"
  fi

  shift 1

  if is_service_running "${service_name}"; then
    compose exec "${service_name}" "${@}"
  else
    compose run --rm "${service_name}" "${@}"
  fi
}

#
# Help text for custom command
#
# usage: help
#
help() {
  cat <<- CommandUsage
		Docker Service Manager v1.0.0

		Proxy the execution of frequently used commands to the corresponding
		Docker Compose services. Supports DDEV and Laravel Sail environments.

		Usage:
		dsm [command] [options] [arguments]

		Commands:
		  init      Create a docker compose configuration.
		  config    Retrieve the docker compose configuration.
		  up        Start all containers of the current project.
		  down      Stop all containers of the current project.
		  restart   Restart all containers of the current project.
		  ps        List all containers of the current project.
		  shell     Start a shell session.
		  stats     Display resource usage statistics.
		  artisan   Run an Artisan command.
		  bundle    Run a Bundler command.
		  compass   Run a Compass command.
		  composer  Run a Composer command.
		  drupal    Run a Drupal Console command.
		  drush     Run a Drush command.
		  gem       Run a Ruby gem.
		  jekyll    Run a Jekyll command.
		  kirby     Run a Kirby CLI command.
		  node      Run a Node snippet.
		  npm       Run a npm command.
		  npx       Run a npx command.
		  php       Run a PHP snippet.
		  phpcs     Run PHP CodeSniffer.
		  phpstan   Run PHPStan.
		  phpunit   Run a PHPUnit test.
		  pint      Run Pint a code style fixer.
		  ruby      Run a Ruby snippet.
		  wp        Run WordPress CLI command.
	CommandUsage
}

#
# Main entry point of the script.
#
# usage: main [command] [options] [arguments]
#
main() {
  local command="${1:-help}"
  shift 1

  case "${command}" in
    h|help)
      help
      ;;
    i|init)
      init "${@}"
      ;;
    c|config)
      compose config "${@}"
      ;;
    up)
      compose up "${@}"
      ;;
    down)
      compose down "${@}"
      ;;
    restart)
      compose restart "${@}"
      ;;
    ps)
      compose ps --format "table {{.ID}}\t{{.Name}}\t{{.Service}}\t{{.Status}}\t{{.Image}}" "${@}"
      ;;
    stats)
      compose stats "${@}"
      ;;
    sh|shell)
      run app sh "${@}"
      ;;
    artisan)
      run php php artisan "${@}"
      ;;
    bundle)
      run ruby bundle "${@}"
      ;;
    compass)
      run ruby bundle exec compass "${@}"
      ;;
    composer)
      run php composer "${@}"
      ;;
    drupal)
      run php php ./vendor/bin/drupal "${@}"
      ;;
    drush)
      run php php ./vendor/bin/drush "${@}"
      ;;
    gem)
      run ruby gem "${@}"
      ;;
    jekyll)
      run ruby bundle exec jekyll "${@}"
      ;;
    kirby)
      run php php ./vendor/bin/kirby "${@}"
      ;;
    node)
      run node node "${@}"
      ;;
    npm)
      run node npm "${@}"
      ;;
    npx)
      run node npx "${@}"
      ;;
    php)
      run php php "${@}"
      ;;
    phpcs)
      run php php ./vendor/bin/phpcs "${@}"
      ;;
    phpstan)
      run php php ./vendor/bin/phpstan "${@}"
      ;;
    phpunit)
      run php php ./vendor/bin/phpunit "${@}"
      ;;
    pint)
      run php php ./vendor/bin/pint "${@}"
      ;;
    ruby)
      run ruby ruby "${@}"
      ;;
    wp|wordpress)
      run php php ./vendor/bin/wp "${@}"
      ;;
    *)
      echo "Unknown command [${command}]" >&2
      help
      ;;
  esac
}

main "${@}"


# vim:foldmethod=marker:foldlevel=2
