#!/usr/bin/env bash
#
# @file Proxy command executions to running docker containers.

#
# Determine whether docker is running
#
# usage: is_docker_running
#
is_docker_running() {
  docker info >/dev/null 2>&1
}

#
# Determine whether a command with the given name exists in the current
# environment.
#
# usage: command_exists <name>
#
command_exists() {
  command -v "${1}" >/dev/null 2>&1
}

#
# Print a status message.
#
# usage: print_message <message>
#
print_message() {
  echo -e "\\033[0;34m==> $*\\033[0;m"
}

#
# Print an error message.
#
# usage: print_error <message>
#
print_error() {
  echo -e "\\033[0;31m==> $*\\033[0;m" >&2
}

#
# Print a warning message.
#
# usage: print_warning <message>
#
print_warning() {
  echo -e "\\033[0;33m==> $*\\033[0;m" >&2
}

#
# Search for a file in the current directory hierarchy.
#
# usage: find_file <name> [<directory>]
#
find_file() {
  local file="${1}"
  local current_directory="${2:-$PWD}"

  while [[ "${current_directory}" != "/" ]]; do
    if [[ -r "${current_directory}/${file}" ]]; then
      echo "${current_directory}/${file}"
      return 0
    fi
    current_directory="$(dirname "${current_directory}")"
  done

  return 1
}

#
# Get the path to the root directory of the current project.
#
# usage: get_project_root
#
get_project_root() {
  local project_markers=(
    "composer.json"
    "package.json"
    ".git"
    ".github"
    ".ddev"
    ".vscode"
    ".env"
    ".editorconfig"
  )

  local marker_name
  local marker_file

  for marker_name in "${project_markers[@]}"; do
    marker_file="$(find_file "${marker_name}")"

    if [[ -r "${marker_file}" ]]; then
      dirname "${marker_file}"
      return 0
    fi
  done

  return 1
}

#
# Get the path to the configuration file of the docker compose project.
#
# usage: get_compose_config
#
get_compose_config() {
  local working_dir="${1}"

  local config_files=(
    "${working_dir}/.ddev/.ddev-docker-compose-full.yaml"
    "${working_dir}/compose.yml"
    "${working_dir}/docker-compose.yml"
  )

  local config_file

  for config_file in "${config_files[@]}"; do
    if [[ -r "${config_file}" ]]; then
      echo "${config_file}"
      return 0
    fi
  done

  return 1
}

#
# Find the first service that exists from a list of candidates.
#
# usage: get_compose_service <file> <name> [<name>] [<name>] [â€¦]
#
get_compose_service() {
  local config_file="${1}"
  shift 1

  if [[ ! -r "${config_file}" ]]; then
    return 1
  fi

  local services
  services="$(docker compose --file "${config_file}" config --services 2>/dev/null)"

  if [[ -z "${services}" ]]; then
    return 1
  fi

  local service

  for service in "${@}"; do
    if grep -q -E "\b${service}\b" <<< "${services}"; then
      echo "${service}"
      return 0
    fi
  done

  return 1
}

#
# Help text for custom command
#
# usage: help
#
help() {
  cat <<- CommandUsage
		DOCSY v1.0.0

		Proxy the execution of frequently used commands to the corresponding
		Docker Compose services. Supports DDEV and Laravel Sail environments.

		Usage:
		docsy <command> [options] [arguments]

		Commands:
		  up        Start all containers of the current project.
		  down      Stop all containers of the current project.
		  restart   Restart all containers of the current project.
		  node      Run a Node command.
		  npm       Run a npm command.
		  npx       Run a npx command.
		  php       Run a snippet of PHP code.
		  composer  Run a Composer command.
		  artisan   Run an Artisan command.
		  kirby     Run a Kirby CLI command.
		  drupal    Run a Drupal Console command.
		  drush     Run a Drush command.
		  phpunit   Run a PHPUnit test.
		  phpcs     Run PHP CodeSniffer.
		  pint      Run Pint a code style fixer.
		  wp        Run WordPress CLI command.
	CommandUsage
}

#
# Main entry point of the script.
#
# usage: docsy [options] [<cmd>] [arguments]
#
main() {
  if ! command_exists "docker"; then
    print_error "Command [docker] is not defined"
    return 1
  fi

  if ! is_docker_running; then
    print_error "Docker is not running"
    return 1
  fi

  local project_root
  project_root="$(get_project_root)"

  if [[ ! -d "${project_root}" ]]; then
    print_error "Could not determine project root"
    return 1
  fi

  local config_file
  config_file="$(get_compose_config "${project_root}")"

  if [[ ! -r "${config_file}" ]]; then
    print_error "Docker compose configuration not found"
    return 1
  fi

  if [[ -r "${project_root}/.env.local" ]]; then
    source "${project_root}/.env.local"
  elif [[ -r "${project_root}/.env" ]]; then
    source "${project_root}/.env"
  fi

  local php_service
  php_service="$(
    get_compose_service "${config_file}" \
      "${PHP_SERVICE:-php}" \
      "${APP_SERVICE:-laravel.test}" \
      "app" \
      "web"
  )"

  local node_service
  node_service="$(
    get_compose_service "${config_file}" \
      "${NODE_SERVICE:-node}" \
      "${APP_SERVICE:-laravel.test}" \
      "app" \
      "web"
  )"

  local command="${1}"
  shift 1

  local options=()

  for option in "$@"; do
    case "${option}" in
      -e|--env)
        options+=(--env "${2}")
        shift 2
        ;;
      -u|--user)
        options+=(--user "${2}")
        shift 2
        ;;
    esac
  done

  case "${command}" in
    help)
      help
      ;;
    up)
      docker compose --file "${config_file}" up "${@}"
      ;;
    down)
      docker compose --file "${config_file}" down "${@}"
      ;;
    config)
      docker compose --file "${config_file}" config "${@}"
      ;;
    restart)
      docker compose --file "${config_file}" restart "${@}"
      ;;
    ruby|bundle|gem)
      docker compose --file "${config_file}" exec "${options[@]}" "${ruby_service:-ruby}" \
        "${command}" "${@}"
      ;;
    node|npm|npx)
      docker compose --file "${config_file}" exec "${options[@]}" "${node_service:-node}" \
        "${command}" "${@}"
      ;;
    php|composer)
      docker compose --file "${config_file}" exec "${options[@]}" "${php_service:-php}" \
        php "${@}"
      ;;
    artisan)
      docker compose --file "${config_file}" exec "${options[@]}" "${php_service:-php}" \
        php artisan "${@}"
      ;;
    phpunit|phpcs|phpstan|pint|drupal|drush|kirby|wp)
      docker compose --file "${config_file}" exec "${options[@]}" "${php_service:-php}" \
        "./vendor/bin/${command}" "${@}"
      ;;
    *)
      print_error "Unknown command [${command}]"
      help
      ;;
  esac
}

main "$@"

# vim:foldmethod=marker:foldlevel=2
